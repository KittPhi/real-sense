from ctypes import c_int, POINTER, c_float, c_char_p, c_void_p, CDLL
from ctypes import Structure, byref
import os
import platform
from typing import Sequence
from collections import namedtuple
import numpy as np

from cubemos.core.nativewrapper import (
    CM_Image,
    CM_ReturnCode,
    CM_TargetComputeDevice,
    CM_Datatype,
    CM_MemoryOrder,
)

__all__ = ["CubemosException", "Coordinate", "SkeletonKeypoints", "Api"]


cubemos_dir = os.path.join(os.environ["CUBEMOS_SKEL_SDK"])

if platform.system() == "Linux":
        _cubemos_skel_tracking = CDLL(
            os.path.join(cubemos_dir, "lib", "libcubemos_skeleton_tracking.so")
        )
elif platform.system() == "Windows":
    path_options = [
        os.path.join(cubemos_dir, "bin", "cubemos_skeleton_tracking.dll"),
        os.path.join(cubemos_dir, "cubemos_skeleton_tracking.dll"),
    ]
    if os.path.exists(path_options[0]):
        _cubemos_skel_tracking = CDLL(path_options[0])
    else:
        _cubemos_skel_tracking = CDLL(path_options[1])
else:
    raise Exception("{} is not supported".format(platform.system()))


class CM_SKEL_KeypointsBuffer(Structure):
    _fields_ = [
        ("id", c_int),
        ("numKeyPoints", c_int),
        ("keypoints_coord_x", POINTER(c_float)),
        ("keypoints_coord_y", POINTER(c_float)),
        ("confidences", POINTER(c_float)),
    ]


class CM_SKEL_Buffer(Structure):
    _fields_ = [
        ("skeletons", POINTER(CM_SKEL_KeypointsBuffer)),
        ("numSkeletons", c_int),
    ]


class CM_SKEL_Handle(Structure):
    pass


class CM_SKEL_AsyncRequestHandle(Structure):
    pass


_cubemos_skel_tracking.cm_skel_create_handle.restype = c_int
_cubemos_skel_tracking.cm_skel_create_handle.argtypes = (
    POINTER(POINTER(CM_SKEL_Handle)),
    c_char_p,
)

_cubemos_skel_tracking.cm_skel_load_model.restype = c_int
_cubemos_skel_tracking.cm_skel_load_model.argtypes = (
    POINTER(CM_SKEL_Handle),
    c_int,
    c_char_p,
)

_cubemos_skel_tracking.cm_skel_estimate_keypoints.restype = c_int
_cubemos_skel_tracking.cm_skel_estimate_keypoints.argtypes = (
    POINTER(CM_SKEL_Handle),
    POINTER(CM_Image),
    c_int,
    POINTER(CM_SKEL_Buffer),
)


_cubemos_skel_tracking.cm_skel_update_tracking_id.restype = c_int
_cubemos_skel_tracking.cm_skel_update_tracking_id.argtypes = (
    POINTER(CM_SKEL_Handle),
    POINTER(CM_SKEL_Buffer),
    POINTER(CM_SKEL_Buffer),
)

_cubemos_skel_tracking.cm_skel_release_buffer.restype = c_int
_cubemos_skel_tracking.cm_skel_release_buffer.argtypes = (POINTER(CM_SKEL_Buffer),)


_cubemos_skel_tracking.cm_skel_destroy_handle.restype = c_int
_cubemos_skel_tracking.cm_skel_destroy_handle.argtypes = (
    POINTER(POINTER(CM_SKEL_Handle)),
)


class CubemosException(Exception):
    global _cubemos_skel_tracking

    def __init__(self, message, error_code=None):
        super().__init__(message)
        self.error_code = error_code


def handle_return_code(return_code):
    if return_code == CM_ReturnCode.CM_SUCCESS:
        pass
    else:
        raise CubemosException("Non-Success Return Code", return_code)


class ManagedSkelHandle:
    def __init__(self, handle: POINTER(CM_SKEL_Handle)):
        assert isinstance(handle, POINTER(CM_SKEL_Handle))
        self._handle = handle

    def get_raw_handle(self):
        return self._handle

    def __del__(self):
        global _cubemos_skel_tracking
        retval = _cubemos_skel_tracking.cm_skel_destroy_handle(byref(self._handle))
        handle_return_code(retval)


class ManagedAsyncSkelHandle:
    def __init__(self, handle: POINTER(CM_SKEL_AsyncRequestHandle)):
        self._handle = handle

    def get_raw_handle(self):
        return self._handle

    def __del__(self):
        global _cubemos_skel_tracking
        retval = _cubemos_skel_tracking.cm_skel_destroy_async_request_handle(
            POINTER(self._handle)
        )
        handle_return_code(retval)


Coordinate = namedtuple("Coordinate", ["x", "y"])


SkeletonKeypoints = namedtuple("SkeletonKeypoints", ["joints", "confidences", "id"])


class Api:
    """Wrapper class for the Native Api.

    All exposed functionality of the native api is implemented in this class
    """
    global _cubemos_skel_tracking

    def __init__(self, license_folder: str):
        """The Constructor

        Parameters
        ----------
        license_folder : str
            The path to the folder where your license key (cubemos_license.json) is stored
        """
        raw_handle = POINTER(CM_SKEL_Handle)()
        retval = _cubemos_skel_tracking.cm_skel_create_handle(
            byref(raw_handle), c_char_p(os.fsencode(license_folder))
        )
        handle_return_code(retval)
        self.managed_handle = ManagedSkelHandle(raw_handle)

    def load_model(self, device: CM_TargetComputeDevice, model_path: str):
        """Loads a model from the filesystem for a specific device (CPU or GPU)

        Parameters
        ----------
        device : CM_TargetComputeDevice
            The Type of device you want to use. Can be one of the three Choices:
            CM_TargetComputeDevice.CM_CPU,
            CM_TargetComputeDevice.CM_GPU,
            CM_TargetComputeDevice.CM_MYRIAD
        model_path: str
            relative or absolute path to the model file (*.cubemos)
        """
        ret_code = _cubemos_skel_tracking.cm_skel_load_model(
            self.managed_handle.get_raw_handle(),
            c_int(device),
            c_char_p(os.fsencode(model_path)),
        )
        handle_return_code(ret_code)

    def estimate_keypoints(
        self, image: np.ndarray, network_height: int
    ) -> Sequence[SkeletonKeypoints]:
        """Estimate the skeleton keypoints given an input image

        Parameters:
        ----------
        image: numpy.ndarray
            An image encoded in a numpy array. Expects the same format as used by 
            OpenCv.
        network_height: int
            The internal resolution of the network. Has to be divisible by 16. 
            Smaller height means less time for estimation but with lower accuracy too
        """
        c_img = wrap_numpy_image(image)
        raw_skel_buffer = CM_SKEL_Buffer()
        ret_code = _cubemos_skel_tracking.cm_skel_estimate_keypoints(
            self.managed_handle.get_raw_handle(),
            byref(c_img),
            c_int(network_height),
            byref(raw_skel_buffer),
        )
        handle_return_code(ret_code)
        skeletons = convert_skeletons(raw_skel_buffer)
        handle_return_code(
            _cubemos_skel_tracking.cm_skel_release_buffer(byref(raw_skel_buffer))
        )
        return skeletons

    def update_tracking_id(
        self,
        last_skeletons: Sequence[SkeletonKeypoints],
        current_skeletons: Sequence[SkeletonKeypoints],
    ) -> Sequence[SkeletonKeypoints]:
        """
        Function to associate ids of the current skeleton results with the 
        results of the last frame

        Parameters:
        ----------
        last_skeletons : Sequence[SkeletonKeypoints]
            the skeletons buffer with coordinate information of the skeletons
            estimated in the last image with respect to which the IDs in the 
            current skeletons buffer will be updated
        current_skeletons : Sequence[SkeletonKeypoints]
            the skeletons buffer with coordinate information of the skeletons
            estimated in the current frame which needs their tracking IDs to 
            be updated based on their last assigned IDs
        
        Returns
        -------
        skeletons : Sequence[SkeletonKeypoints]
            A copy of the second parameter with updated tracking id.
        """
        cm_last_skels = convert_skeletons_reverse(last_skeletons)
        cm_current_skels = convert_skeletons_reverse(current_skeletons)
        ret_code = _cubemos_skel_tracking.cm_skel_update_tracking_id(
            self.managed_handle.get_raw_handle(),
            byref(cm_last_skels),
            byref(cm_current_skels),
        )
        updated_skeletons = convert_skeletons(cm_current_skels)
        handle_return_code(ret_code)
        return updated_skeletons

    def __del__(self):
        del self.managed_handle


##############################################################################
######### Private functions
##############################################################################


def convert_skeletons(raw_skel_buffer: CM_SKEL_Buffer):
    skeletons = []
    for index in range(raw_skel_buffer.numSkeletons):
        raw_skel = raw_skel_buffer.skeletons[index]
        joints = []
        confidences = []
        id = raw_skel.id
        for keypoint_index in range(raw_skel.numKeyPoints):
            joints.append(
                Coordinate(
                    raw_skel.keypoints_coord_x[keypoint_index],
                    raw_skel.keypoints_coord_y[keypoint_index],
                )
            )
            confidences.append(raw_skel.confidences[keypoint_index])
        skeletons.append(SkeletonKeypoints(joints, confidences, id))
    return skeletons


def convert_skeletons_reverse(skeletons: Sequence[SkeletonKeypoints]) -> CM_SKEL_Buffer:
    raw_skel_buffer = CM_SKEL_Buffer()
    raw_skel_buffer.numSkeletons = len(skeletons)
    raw_skel_buffer.skeletons = (CM_SKEL_KeypointsBuffer * len(skeletons))()
    for index in range(len(skeletons)):
        raw_skel_buffer.skeletons[index].id = skeletons[index].id
        num_keypoints = len(skeletons[index].joints)
        raw_skel_buffer.skeletons[index].numKeyPoints = num_keypoints
        raw_skel_buffer.skeletons[index].keypoints_coord_x = (c_float * num_keypoints)()
        raw_skel_buffer.skeletons[index].keypoints_coord_y = (c_float * num_keypoints)()
        raw_skel_buffer.skeletons[index].confidences = (c_float * num_keypoints)()
        for keypoint_index in range(num_keypoints):
            raw_skel_buffer.skeletons[index].keypoints_coord_x[keypoint_index] = (
                skeletons[index].joints[keypoint_index].x
            )
            raw_skel_buffer.skeletons[index].keypoints_coord_y[keypoint_index] = (
                skeletons[index].joints[keypoint_index].y
            )
            raw_skel_buffer.skeletons[index].confidences[keypoint_index] = skeletons[
                index
            ].confidences[keypoint_index]
    return raw_skel_buffer


def translate_dtype(numpy_dtype):
    if numpy_dtype == np.uint8:
        return CM_Datatype.CM_UINT8
    if numpy_dtype == np.int8:
        return CM_Datatype.CM_INT8
    if numpy_dtype == np.int16:
        return CM_Datatype.CM_INT16
    if numpy_dtype == np.float16:
        return CM_Datatype.CM_FLOAT16
    if numpy_dtype == np.float32:
        return CM_Datatype.CM_FLOAT32
    raise CubemosException("{} cannot be used as input type".format(numpy_dtype))


def wrap_numpy_image(image: np.ndarray) -> CM_Image:
    if not isinstance(image, np.ndarray):
        raise CubemosException("The input image has to be a numpy ndarray")
    img = np.ascontiguousarray(image)
    if len(img.shape) == 2:
        channels = 1
    if len(img.shape) == 3:
        channels = img.shape[2]
    else:
        raise CubemosException(
            "The input image has unmatching dimensions. Images can be 2D for grayscale images and 3D for color images"
        )
    c_img = CM_Image(
        data=img.ctypes.data_as(c_void_p),
        dataType=translate_dtype(img.dtype),
        nWidth=img.shape[1],
        nHeight=img.shape[0],
        nChannels=channels,
        nStride=img.strides[0],
        imageLayout=CM_MemoryOrder.CM_HWC,
    )
    return c_img
